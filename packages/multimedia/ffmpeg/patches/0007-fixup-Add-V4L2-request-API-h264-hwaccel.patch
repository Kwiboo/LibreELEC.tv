From 61a570b4a54b44c7ee86bf897ef38db0ed09e8da Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 8 Dec 2018 10:40:21 +0100
Subject: [PATCH] fixup! Add V4L2 request API h264 hwaccel

---
 libavcodec/v4l2_request_h264.c | 210 +++++++++++++++++++--------------
 1 file changed, 120 insertions(+), 90 deletions(-)

diff --git a/libavcodec/v4l2_request_h264.c b/libavcodec/v4l2_request_h264.c
index 7a8e84c7cf..50e44a335f 100644
--- a/libavcodec/v4l2_request_h264.c
+++ b/libavcodec/v4l2_request_h264.c
@@ -28,8 +28,7 @@ typedef struct V4L2RequestControlsH264 {
     struct v4l2_ctrl_h264_slice_param slice_params;
 } V4L2RequestControlsH264;
 
-static void fill_single_pred_weight_table(const H264SliceContext *sl, int list,
-                                          struct v4l2_h264_weight_factors *factors)
+static void fill_weight_factors(struct v4l2_h264_weight_factors *factors, int list, const H264SliceContext *sl)
 {
     for (int i = 0; i < sl->ref_count[list]; i++) {
         if (sl->pwt.luma_weight_flag[list]) {
@@ -51,7 +50,7 @@ static void fill_single_pred_weight_table(const H264SliceContext *sl, int list,
     }
 }
 
-static void dpb_add(struct v4l2_h264_dpb_entry *entry, const H264Picture *pic)
+static void fill_dpb_entry(struct v4l2_h264_dpb_entry *entry, const H264Picture *pic)
 {
     entry->tag = ff_v4l2_request_get_capture_tag(pic->f);
     entry->frame_num = pic->frame_num;
@@ -65,15 +64,14 @@ static void dpb_add(struct v4l2_h264_dpb_entry *entry, const H264Picture *pic)
     entry->bottom_field_order_cnt = pic->field_poc[1];
 }
 
-static void fill_dpb(struct v4l2_ctrl_h264_decode_param *decode,
-                     const H264Context                  *h)
+static void fill_dpb(struct v4l2_ctrl_h264_decode_param *decode, const H264Context *h)
 {
     int entries = 0;
 
     for (int i = 0; i < h->short_ref_count; i++) {
         const H264Picture *pic = h->short_ref[i];
         if (pic)
-            dpb_add(&decode->dpb[entries++], pic);
+            fill_dpb_entry(&decode->dpb[entries++], pic);
     }
 
     if (!h->long_ref_count)
@@ -82,51 +80,35 @@ static void fill_dpb(struct v4l2_ctrl_h264_decode_param *decode,
     for (int i = 0; i < FF_ARRAY_ELEMS(h->long_ref); i++) {
         const H264Picture *pic = h->long_ref[i];
         if (pic)
-            dpb_add(&decode->dpb[entries++], pic);
+            fill_dpb_entry(&decode->dpb[entries++], pic);
     }
 }
 
-static uint8_t get_ref_pic_index(const H264Ref *ref,
-                                 struct v4l2_ctrl_h264_decode_param *decode)
+static uint8_t get_dpb_index(struct v4l2_ctrl_h264_decode_param *decode, const H264Ref *ref)
 {
-    const H264Picture *pic = ref->parent;
-    int frame_buf_tag;
-    int frame_num;
-    int pic_num;
-    uint8_t i;
+    uint32_t tag;
 
-    if (!pic)
+    if (!ref->parent)
         return 0;
 
-    frame_buf_tag = ff_v4l2_request_get_capture_tag(pic->f);
-    frame_num = pic->frame_num;
-    pic_num = pic->pic_id;
+    tag = ff_v4l2_request_get_capture_tag(ref->parent->f);
 
-    for (i = 0; i < FF_ARRAY_ELEMS(decode->dpb); i++) {
+    for (uint8_t i = 0; i < FF_ARRAY_ELEMS(decode->dpb); i++) {
         struct v4l2_h264_dpb_entry *entry = &decode->dpb[i];
         if ((entry->flags & V4L2_H264_DPB_ENTRY_FLAG_VALID) &&
-            (entry->tag == frame_buf_tag) &&
-            (entry->frame_num == frame_num) &&
-            (entry->pic_num == pic_num))
+            entry->tag == tag)
             // TODO: signal reference type, possible using top 2 bits
-            return i /* | ((ref->reference & 3) << 6) */;
+            return i | ((ref->reference & 3) << 6);
     }
 
     return 0;
 }
 
-static int v4l2_request_h264_start_frame(AVCodecContext *avctx,
-                                         av_unused const uint8_t *buffer,
-                                         av_unused uint32_t size)
+static void fill_sps(struct v4l2_ctrl_h264_sps *ctrl, const H264Context *h)
 {
-    const H264Context *h = avctx->priv_data;
-    const PPS *pps = h->ps.pps;
     const SPS *sps = h->ps.sps;
-    const H264SliceContext *sl = &h->slice_ctx[0];
-    V4L2RequestControlsH264 *controls = h->cur_pic_ptr->hwaccel_picture_private;
-    int i, count;
 
-    controls->sps = (struct v4l2_ctrl_h264_sps) {
+    *ctrl = (struct v4l2_ctrl_h264_sps) {
         .profile_idc = sps->profile_idc,
         .constraint_set_flags = sps->constraint_set_flags,
         .level_idc = sps->level_idc,
@@ -147,21 +129,27 @@ static int v4l2_request_h264_start_frame(AVCodecContext *avctx,
     };
 
     if (sps->residual_color_transform_flag)
-        controls->sps.flags |= V4L2_H264_SPS_FLAG_SEPARATE_COLOUR_PLANE;
+        ctrl->flags |= V4L2_H264_SPS_FLAG_SEPARATE_COLOUR_PLANE;
     if (sps->transform_bypass)
-        controls->sps.flags |= V4L2_H264_SPS_FLAG_QPPRIME_Y_ZERO_TRANSFORM_BYPASS;
+        ctrl->flags |= V4L2_H264_SPS_FLAG_QPPRIME_Y_ZERO_TRANSFORM_BYPASS;
     if (sps->delta_pic_order_always_zero_flag)
-        controls->sps.flags |= V4L2_H264_SPS_FLAG_DELTA_PIC_ORDER_ALWAYS_ZERO;
+        ctrl->flags |= V4L2_H264_SPS_FLAG_DELTA_PIC_ORDER_ALWAYS_ZERO;
     if (sps->gaps_in_frame_num_allowed_flag)
-        controls->sps.flags |= V4L2_H264_SPS_FLAG_GAPS_IN_FRAME_NUM_VALUE_ALLOWED;
+        ctrl->flags |= V4L2_H264_SPS_FLAG_GAPS_IN_FRAME_NUM_VALUE_ALLOWED;
     if (sps->frame_mbs_only_flag)
-        controls->sps.flags |= V4L2_H264_SPS_FLAG_FRAME_MBS_ONLY;
+        ctrl->flags |= V4L2_H264_SPS_FLAG_FRAME_MBS_ONLY;
     if (sps->mb_aff)
-        controls->sps.flags |= V4L2_H264_SPS_FLAG_MB_ADAPTIVE_FRAME_FIELD;
+        ctrl->flags |= V4L2_H264_SPS_FLAG_MB_ADAPTIVE_FRAME_FIELD;
     if (sps->direct_8x8_inference_flag)
-        controls->sps.flags |= V4L2_H264_SPS_FLAG_DIRECT_8X8_INFERENCE;
+        ctrl->flags |= V4L2_H264_SPS_FLAG_DIRECT_8X8_INFERENCE;
+}
 
-    controls->pps = (struct v4l2_ctrl_h264_pps) {
+static void fill_pps(struct v4l2_ctrl_h264_pps *ctrl, const H264Context *h)
+{
+    const PPS *pps = h->ps.pps;
+    const H264SliceContext *sl = &h->slice_ctx[0];
+
+    *ctrl = (struct v4l2_ctrl_h264_pps) {
         .pic_parameter_set_id = sl->pps_id,
         .seq_parameter_set_id = pps->sps_id,
         .num_slice_groups_minus1 = pps->slice_group_count - 1,
@@ -175,19 +163,31 @@ static int v4l2_request_h264_start_frame(AVCodecContext *avctx,
     };
 
     if (pps->cabac)
-        controls->pps.flags |= V4L2_H264_PPS_FLAG_ENTROPY_CODING_MODE;
+        ctrl->flags |= V4L2_H264_PPS_FLAG_ENTROPY_CODING_MODE;
     if (pps->pic_order_present)
-        controls->pps.flags |= V4L2_H264_PPS_FLAG_BOTTOM_FIELD_PIC_ORDER_IN_FRAME_PRESENT;
+        ctrl->flags |= V4L2_H264_PPS_FLAG_BOTTOM_FIELD_PIC_ORDER_IN_FRAME_PRESENT;
     if (pps->weighted_pred)
-        controls->pps.flags |= V4L2_H264_PPS_FLAG_WEIGHTED_PRED;
+        ctrl->flags |= V4L2_H264_PPS_FLAG_WEIGHTED_PRED;
     if (pps->deblocking_filter_parameters_present)
-        controls->pps.flags |= V4L2_H264_PPS_FLAG_DEBLOCKING_FILTER_CONTROL_PRESENT;
+        ctrl->flags |= V4L2_H264_PPS_FLAG_DEBLOCKING_FILTER_CONTROL_PRESENT;
     if (pps->constrained_intra_pred)
-        controls->pps.flags |= V4L2_H264_PPS_FLAG_CONSTRAINED_INTRA_PRED;
+        ctrl->flags |= V4L2_H264_PPS_FLAG_CONSTRAINED_INTRA_PRED;
     if (pps->redundant_pic_cnt_present)
-        controls->pps.flags |= V4L2_H264_PPS_FLAG_REDUNDANT_PIC_CNT_PRESENT;
+        ctrl->flags |= V4L2_H264_PPS_FLAG_REDUNDANT_PIC_CNT_PRESENT;
     if (pps->transform_8x8_mode)
-        controls->pps.flags |= V4L2_H264_PPS_FLAG_TRANSFORM_8X8_MODE;
+        ctrl->flags |= V4L2_H264_PPS_FLAG_TRANSFORM_8X8_MODE;
+}
+
+static int v4l2_request_h264_start_frame(AVCodecContext *avctx,
+                                         av_unused const uint8_t *buffer,
+                                         av_unused uint32_t size)
+{
+    const H264Context *h = avctx->priv_data;
+    const PPS *pps = h->ps.pps;
+    V4L2RequestControlsH264 *controls = h->cur_pic_ptr->hwaccel_picture_private;
+
+    fill_sps(&controls->sps, h);
+    fill_pps(&controls->pps, h);
 
     memcpy(controls->scaling_matrix.scaling_list_4x4, pps->scaling_matrix4, sizeof(controls->scaling_matrix.scaling_list_4x4));
     memcpy(controls->scaling_matrix.scaling_list_8x8, pps->scaling_matrix8, sizeof(controls->scaling_matrix.scaling_list_8x8));
@@ -205,6 +205,64 @@ static int v4l2_request_h264_start_frame(AVCodecContext *avctx,
 
     fill_dpb(&controls->decode_params, h);
 
+    return ff_v4l2_request_reset_frame(avctx, h->cur_pic_ptr->f);
+}
+
+static int v4l2_request_h264_end_frame(AVCodecContext *avctx)
+{
+    const H264Context *h = avctx->priv_data;
+    V4L2RequestControlsH264 *controls = h->cur_pic_ptr->hwaccel_picture_private;
+    V4L2RequestDescriptor *req = (V4L2RequestDescriptor*)h->cur_pic_ptr->f->data[0];
+
+    struct v4l2_ext_control control[] = {
+        {
+            .id = V4L2_CID_MPEG_VIDEO_H264_SPS,
+            .ptr = &controls->sps,
+            .size = sizeof(controls->sps),
+        },
+        {
+            .id = V4L2_CID_MPEG_VIDEO_H264_PPS,
+            .ptr = &controls->pps,
+            .size = sizeof(controls->pps),
+        },
+        {
+            .id = V4L2_CID_MPEG_VIDEO_H264_SCALING_MATRIX,
+            .ptr = &controls->scaling_matrix,
+            .size = sizeof(controls->scaling_matrix),
+        },
+        {
+            .id = V4L2_CID_MPEG_VIDEO_H264_SLICE_PARAMS,
+            .ptr = &controls->slice_params,
+            .size = sizeof(controls->slice_params),
+        },
+        {
+            .id = V4L2_CID_MPEG_VIDEO_H264_DECODE_PARAMS,
+            .ptr = &controls->decode_params,
+            .size = sizeof(controls->decode_params),
+        },
+    };
+
+    controls->slice_params.size = req->output.used;
+
+    return ff_v4l2_request_decode_frame(avctx, h->cur_pic_ptr->f, control, FF_ARRAY_ELEMS(control));
+}
+
+static int v4l2_request_h264_decode_slice(AVCodecContext *avctx, const uint8_t *buffer, uint32_t size)
+{
+    const H264Context *h = avctx->priv_data;
+    const PPS *pps = h->ps.pps;
+    const H264SliceContext *sl = &h->slice_ctx[0];
+    V4L2RequestControlsH264 *controls = h->cur_pic_ptr->hwaccel_picture_private;
+    V4L2RequestDescriptor *req = (V4L2RequestDescriptor*)h->cur_pic_ptr->f->data[0];
+    int i, count;
+
+    // HACK: trigger decode per slice
+    if (req->output.used) {
+        v4l2_request_h264_end_frame(avctx);
+        ff_v4l2_request_reset_frame(avctx, h->cur_pic_ptr->f);
+        controls->decode_params.num_slices++;
+    }
+
     controls->slice_params = (struct v4l2_ctrl_h264_slice_param) {
         /* Size in bytes, including header */
         .size = 0,
@@ -252,71 +311,42 @@ static int v4l2_request_h264_start_frame(AVCodecContext *avctx,
 
     count = sl->list_count > 0 ? sl->ref_count[0] : 0;
     for (i = 0; i < count; i++)
-        controls->slice_params.ref_pic_list0[i] = get_ref_pic_index(&sl->ref_list[0][i], &controls->decode_params);
+        controls->slice_params.ref_pic_list0[i] = get_dpb_index(&controls->decode_params, &sl->ref_list[0][i]);
     if (count)
-        fill_single_pred_weight_table(sl, 0, &controls->slice_params.pred_weight_table.weight_factors[0]);
+        fill_weight_factors(&controls->slice_params.pred_weight_table.weight_factors[0], 0, sl);
 
     count = sl->list_count > 1 ? sl->ref_count[1] : 0;
     for (i = 0; i < count; i++)
-        controls->slice_params.ref_pic_list1[i] = get_ref_pic_index(&sl->ref_list[1][i], &controls->decode_params);
+        controls->slice_params.ref_pic_list1[i] = get_dpb_index(&controls->decode_params, &sl->ref_list[1][i]);
     if (count)
-        fill_single_pred_weight_table(sl, 1, &controls->slice_params.pred_weight_table.weight_factors[1]);
-
-    return ff_v4l2_request_reset_frame(avctx, h->cur_pic_ptr->f);
-}
-
-static int v4l2_request_h264_decode_slice(AVCodecContext *avctx, const uint8_t *buffer, uint32_t size)
-{
-    const H264Context *h = avctx->priv_data;
-    V4L2RequestControlsH264 *controls = h->cur_pic_ptr->hwaccel_picture_private;
-
-    controls->decode_params.num_slices++;
+        fill_weight_factors(&controls->slice_params.pred_weight_table.weight_factors[1], 1, sl);
 
     return ff_v4l2_request_append_output_buffer(avctx, h->cur_pic_ptr->f, buffer, size);
 }
 
-static int v4l2_request_h264_end_frame(AVCodecContext *avctx)
+static int v4l2_request_h264_init(AVCodecContext *avctx)
 {
     const H264Context *h = avctx->priv_data;
-    V4L2RequestControlsH264 *controls = h->cur_pic_ptr->hwaccel_picture_private;
-    V4L2RequestDescriptor *req = (V4L2RequestDescriptor*)h->cur_pic_ptr->f->data[0];
+    struct v4l2_ctrl_h264_sps sps;
+    struct v4l2_ctrl_h264_pps pps;
 
     struct v4l2_ext_control control[] = {
         {
             .id = V4L2_CID_MPEG_VIDEO_H264_SPS,
-            .ptr = &controls->sps,
-            .size = sizeof(controls->sps),
+            .ptr = &sps,
+            .size = sizeof(sps),
         },
         {
             .id = V4L2_CID_MPEG_VIDEO_H264_PPS,
-            .ptr = &controls->pps,
-            .size = sizeof(controls->pps),
-        },
-        {
-            .id = V4L2_CID_MPEG_VIDEO_H264_SCALING_MATRIX,
-            .ptr = &controls->scaling_matrix,
-            .size = sizeof(controls->scaling_matrix),
-        },
-        {
-            .id = V4L2_CID_MPEG_VIDEO_H264_SLICE_PARAMS,
-            .ptr = &controls->slice_params,
-            .size = sizeof(controls->slice_params),
-        },
-        {
-            .id = V4L2_CID_MPEG_VIDEO_H264_DECODE_PARAMS,
-            .ptr = &controls->decode_params,
-            .size = sizeof(controls->decode_params),
+            .ptr = &pps,
+            .size = sizeof(pps),
         },
     };
 
-    controls->slice_params.size = req->output.used;
+    fill_sps(&sps, h);
+    fill_pps(&pps, h);
 
-    return ff_v4l2_request_decode_frame(avctx, h->cur_pic_ptr->f, control, FF_ARRAY_ELEMS(control));
-}
-
-static int v4l2_request_h264_init(AVCodecContext *avctx)
-{
-    return ff_v4l2_request_init(avctx, V4L2_PIX_FMT_H264_SLICE, 1024 * 1024, NULL, 0);
+    return ff_v4l2_request_init(avctx, V4L2_PIX_FMT_H264_SLICE, 1024 * 1024, control, FF_ARRAY_ELEMS(control));
 }
 
 const AVHWAccel ff_h264_v4l2request_hwaccel = {
-- 
2.19.2

